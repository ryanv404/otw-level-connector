#!/usr/bin/env expect

array set LDATA [list {maze}       {2225 9}    \
                      {natas}      {0000 34}   \
                      {utumno}     {2227 8}    \
                      {narnia}     {2226 9}    \
                      {vortex}     {2228 27}   \
                      {bandit}     {2220 34}   \
                      {krypton}    {2231 7}    \
                      {manpage}    {2224 7}    \
                      {drifter}    {2230 15}   \
                      {behemoth}   {2221 8}    \
                      {leviathan}  {2223 7}    \
                      {formulaone} {2232 6}]

proc get_all_variables {varname} {
  global $varname
  set ctypes_list {}
  if {[array exists $varname]} {
    set asize [array size $varname]
    puts "\033\[0;95m$varname (array)\033\[0;0m:"
    foreach {n v} [array get $varname] {
      puts "  \033\[0;95m$varname\($n\)\033\[0;0m = $v\033\[0;0m"
    }
    return 0
  }
  if {[string is list [set $varname]] && [llength [set $varname]] > 1} {
    puts "\033\[0;36m$varname (list)\033\[0;0m:"
    set lsize [llength [set $varname]]
    for {set i 0} {$i < $lsize} {incr i} {
      puts "  \033\[0;36m$varname\[$i]\033\[0;0m = [lindex [set $varname] $i]"
    }
    return 0
  }
  if {[string is integer -strict [set $varname]]} {
    puts "\033\[0;94m$varname (integer)\033\[0;0m = [set $varname]"
    return 0
  } elseif {[string is double -strict [set $varname]]} {
    puts "\033\[0;92m$varname (double)\033\[0;0m = [set $varname]"
    return 0
  } elseif {[string is entier -strict [set $varname]]} {
    puts "\033\[0;92m$varname (entier)\033\[0;0m = [set $varname]"
    return 0
  } elseif {[string is wideinteger -strict [set $varname]]} {
    puts "\033\[0;92m$varname (wideinteger)\033\[0;0m = [set $varname]"
    return 0
  } else {
    puts "\033\[0;93m$varname (string)\033\[0;0m = [set $varname]"
    return 0
  }

  # if {[string is ascii -strict [set $varname]]} {lappend ctypes_list "ascii"}
  # if {[string is print -strict [set $varname]]} {
  #   lappend ctypes_list "print"
  #   if {[string is graph -strict [set $varname]]} {
  #     lappend ctypes_list "graph"
  #     if {[string is alnum -strict [set $varname]]} {
  #       lappend ctypes_list "alnum"
  #       if {[string is alpha -strict [set $varname]]} {
  #         lappend ctypes_list "alpha"
  #         if {[string is upper -strict [set $varname]]} {
  #           lappend ctypes_list "upper"
  #         } elseif {[string is lower -strict [set $varname]]} {
  #           lappend ctypes_list "lower"
  #         }
  #         if {[string is wordchar -strict [set $varname]]} {lappend ctypes_list "wordchar"}
  #       }
  #       if {[string is digit -strict [set $varname]]} {
  #         lappend ctypes_list "digit"
  #         if {[string is xdigit -strict [set $varname]]} {lappend ctypes_list "xdigit"}
  #       }
  #     } elseif {[string is punct -strict [set $varname]]} {
  #       lappend ctypes_list "punct"
  #     }
  #   } elseif {[string is space -strict [set $varname]]} {
  #     lappend ctypes_list "space"
  #   }
  # }
  # if {[string is control -strict [set $varname]]} {lappend ctypes_list "control"}
  # if {[string is boolean -strict [set $varname]]} {
  #     lappend ctypes_list "boolean"
  #     if {[string is true -strict [set $varname]]} {
  #       lappend ctypes_list "true"
  #     } elseif {[string is false -strict [set $varname]]} {
  #       lappend ctypes_list "false"
  #     }
  # }
  puts "$varname (unknown type) = [set $varname]"
  return 0
}

proc test_level_parsing {level_regex} {
  set num_tests_failed 0
  foreach {lname} [lsort [array names ::LEVELS_DATA]] {
    set test_failure_present 0
    for {set i 0} {$i < 3} {incr i} {
      set lmax [lindex [split "$::LEVELS_DATA($lname)" " "] 1]
      set randnum [expr {int(rand() * $lmax)}]
      if {$i == 1} {set randnum [expr {$randnum + 40}]}
      set testlevel "$lname$randnum"
      if {[regexp $level_regex $testlevel -> sub1 sub2]} {
        set levelname [string tolower $sub1]
        # Strips leading zeroes that can cause unintended octal interpretation
        scan $sub2 %d levelnum
        lappend parsing_list "$testlevel|$levelname|$levelnum"
      } else {
        set test_failure_present 1
        incr num_tests_failed
        lappend parsing_list "$testlevel|*FAILED*"
      }
    }
    if {$test_failure_present} {
      puts "\033\[0;91m\[***FAILED***]\033\[0;0m [join $parsing_list " "]"
    } else {
      puts "\033\[0;92m\[PASSED]\033\[0;0m [join $parsing_list " "]"
    }
    unset parsing_list
  }
  if {$num_tests_failed != 0} {
    puts -nonewline "***FAILED*** $num_tests_failed "
    puts "[expr $num_tests_failed == 1 ? "TEST" : "TESTS"] FAILED!"
  }
  return 0
}

###[ TESTS ]#################################
puts "\[+] ALL VARIABLES"
puts "~~~~~~~~~~~~~~~~~"
foreach {var_name} [lsort [lrange [info vars] 0 end]] {
  get_all_variables $var_name
}

puts "\n\[+] TEST LEVEL PARSING"
puts "~~~~~~~~~~~~~~~~~~~~~~"
test_level_parsing { *([[:alpha:]]+) *([[:digit:]]+) *}
