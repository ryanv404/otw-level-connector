#!/usr/bin/env expect

array set LDATA [list {maze}       {2225 9}    \
                      {natas}      {0000 34}   \
                      {utumno}     {2227 8}    \
                      {narnia}     {2226 9}    \
                      {vortex}     {2228 27}   \
                      {bandit}     {2220 34}   \
                      {krypton}    {2231 7}    \
                      {manpage}    {2224 7}    \
                      {drifter}    {2230 15}   \
                      {behemoth}   {2221 8}    \
                      {leviathan}  {2223 7}    \
                      {formulaone} {2232 6}]

proc value_is_actually_a_list {value} {
  if {[string is list $value] && [llength $value] > 1} {
    return 1
  } else {
    return 0
  }
}

proc get_values_from_array {arrname} {
  global $arrname
  foreach {keyname value} [array get $arrname] {
    if {[value_is_actually_a_list $value]} {
      get_values_from_list "$arrname\($keyname\)" $value
    } else {
      puts "$arrname\($keyname\) = [get_type_from_value $value]"
    }
  }
}

proc get_values_from_list {list_label listvals} {
  set lsize [llength $listvals]
  for {set i 0} {$i < $lsize} {incr i} {
    if {[value_is_actually_a_list [lindex $listvals $i]]} {
      get_values_from_list "$list_label\[$i\]" [lindex $listvals $i]
    } else {
      puts "$list_label\[$i\] = [get_type_from_value [lindex $listvals $i]]"
    }
  }
}

proc get_type_from_value {value} {
  set FMT_GRN "\033\[0;92m"
  set FMT_YEL "\033\[0;93m"
  set FMT_BLUE "\033\[0;94m"
  set FMT_PURP "\033\[0;95m"
  set FMT_CYAN "\033\[0;96m"
  set FMT_CLR "\033\[0;0m"

  if {[string is integer -strict $value]} {
    return "$value${FMT_CLR} (${FMT_GRN}integer${FMT_CLR})"
  } elseif {[string is double -strict $value]} {
    return "$value${FMT_CLR} (${FMT_PURP}double${FMT_CLR})"
  } elseif {[string is entier -strict $value]} {
    return "$value${FMT_CLR} (${FMT_YEL}entier${FMT_CLR})"
  } elseif {[string is wideinteger -strict $value]} {
    return "$value${FMT_CLR} (${FMT_BLUE}wideinteger${FMT_CLR})"
  } else {
    if {[llength [lrange $value 0 end]] == 0} {
      return "\"\" (${FMT_CYAN}string${FMT_CLR})"
    } else {
      return "[lrange $value 0 end]${FMT_CLR} (${FMT_CYAN}string${FMT_CLR})"
    }
  }
}

proc test_level_parsing {ldata_name} {
  global $ldata_name
  set FMT_RED "\033\[0;91m"
  set FMT_GRN "\033\[0;92m"
  set FMT_CLR "\033\[0;0m"
  set level_regex { *([[:alpha:]]+) *([[:digit:]]+) *}
  set num_tests_failed 0

  foreach {lname} [lsort [array names $ldata_name]] {
    set test_failure_present 0

    for {set i 0} {$i < 3} {incr i} {
      set lmax [lindex [lindex [array get $ldata_name $lname] 1] 1]
      set randnum [expr {int(rand() * $lmax)}]
      if {$i == 1} {set randnum [expr {$randnum + 40}]}

      set testlevel "$lname$randnum"
      if {[regexp $level_regex $testlevel -> sub1 sub2]} {
        set levelname [string tolower $sub1]
        # Strips leading zeroes that can cause unintended octal interpretation
        scan $sub2 %d levelnum
        lappend parsing_list "$testlevel|$levelname|$levelnum"
      } else {
        set test_failure_present 1
        incr num_tests_failed
        lappend parsing_list "*$testlevel|FAILED*"
      }
    }

    if {$test_failure_present} {
      puts "\[${FMT_RED}FAILED${FMT_CLR}] [join $parsing_list " "]"
    } else {
      puts "\[${FMT_GRN}PASSED${FMT_CLR}] [join $parsing_list " "]"
    }
    unset parsing_list
  }

  if {$num_tests_failed != 0} {
    puts "${FMT_RED}\[$num_tests_failed TEST[expr {$num_tests_failed == 1 ? " " : "S "}]FAILED\]${FMT_CLR}"
  } else {
    puts "${FMT_GRN}\[$num_tests_failed TEST[expr {$num_tests_failed == 1 ? " " : "S "}]FAILED\]${FMT_CLR}"
  }

  return 0
}

##[ TESTS ]#################################
puts "~~~~~~~~~~~~~~~~~~~~~~"
puts "\[+] TEST LEVEL PARSING"
puts "~~~~~~~~~~~~~~~~~~~~~~"
test_level_parsing "LDATA"

puts "\n~~~~~~~~~~~~~~~~~"
puts "\[+] ALL VARIABLES"
puts "~~~~~~~~~~~~~~~~~"
foreach {var_name} [lsort [lrange [info vars] 0 end]] {
  if [array exists $var_name] {
    get_values_from_array $var_name
  } else {
    if {[value_is_actually_a_list [set $var_name]]} {
      get_values_from_list "$var_name" [set $var_name]
    } else {
      puts "$var_name = [get_type_from_value [set $var_name]]"
    }
  }
}
