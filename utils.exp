#!/usr/bin/env expect

###[ TEST PROCS ]################################
# Virtually everything is a list in Tcl. This tightens up the meaning.
# proc value_is_actually_a_list {value} {
#   if {[string is list $value] && [llength $value] > 1} {
#     return 1
#   } else {
#     return 0
#   }
# }

# proc get_values_from_array {arr_label arrname} {
#   global $arrname
#   foreach {keyname value} [array get $arrname] {
#     if {[value_is_actually_a_list $value]} {
#       get_values_from_list "$arr_label\($keyname\)" $value
#     } else {
#       puts "$arr_label\($keyname\) = [get_type_from_value $value]"
#     }
#   }
# }

# proc get_values_from_list {list_label listvals} {
#   set lsize [llength $listvals]
#   for {set i 0} {$i < $lsize} {incr i} {
#     if {[value_is_actually_a_list [lindex $listvals $i]]} {
#       get_values_from_list "$list_label\[$i\]" [lindex $listvals $i]
#     } else {
#       puts "$list_label\[$i\] = [get_type_from_value [lindex $listvals $i]]"
#     }
#   }
# }

# proc get_type_from_value {value} {
#   set FMT_GRN "\033\[0;32m"
#   set FMT_YEL "\033\[0;33m"
#   set FMT_BLUE "\033\[0;34m"
#   set FMT_PURP "\033\[0;35m"
#   set FMT_CYAN "\033\[0;36m"
#   set FMT_CLR "\033\[0;0m"

#   # Clear any formatting that snuck in from the value
#   if {[string is integer -strict $value]} {
#     return "${FMT_CLR}$value${FMT_CLR} (${FMT_GRN}integer${FMT_CLR})"
#   } elseif {[string is double -strict $value]} {
#     return "${FMT_CLR}$value${FMT_CLR} (${FMT_BLUE}double${FMT_CLR})"
#   } elseif {[string is entier -strict $value]} {
#     return "${FMT_CLR}$value${FMT_CLR} (${FMT_YEL}entier${FMT_CLR})"
#   } elseif {[string is wideinteger -strict $value]} {
#     return "${FMT_CLR}$value${FMT_CLR} (${FMT_CYAN}wideinteger${FMT_CLR})"
#   } else {
#     if {[llength [lrange $value 0 end]] == 0} {
#       return "${FMT_CLR}\"\" (${FMT_PURP}string${FMT_CLR})"
#     } else {
#       return "${FMT_CLR}[lrange $value 0 end]${FMT_CLR} (${FMT_PURP}string${FMT_CLR})"
#     }
#   }
# }

# proc test_level_parsing {ldata_name} {
#   global $ldata_name
#   set num_tests_failed 0
#   set FMT_RED "\033\[0;31m"
#   set FMT_GRN "\033\[0;32m"
#   set FMT_CLR "\033\[0;0m"

#   set level_regex { *([[:alpha:]]+) *([[:digit:]]+) *}

#   foreach {lname} [lsort [array names $ldata_name]] {
#     set test_failure_present 0

#     for {set i 0} {$i < 3} {incr i} {
#       set lmax [lindex [lindex [array get $ldata_name $lname] 1] 1]
#       set randnum [expr {int(rand() * $lmax)}]
#       if {$i == 1} {set randnum [expr {$randnum + 40}]}

#       set testlevel "$lname$randnum"
#       if {[regexp $level_regex $testlevel -> sub1 sub2]} {
#         set levelname [string tolower $sub1]
#         # Strip leading zeroes that can cause unintended octal interpretation
#         scan $sub2 %d levelnum
#         lappend parsing_list "$testlevel|$levelname|$levelnum"
#       } else {
#         set test_failure_present 1
#         incr num_tests_failed
#         lappend parsing_list "${FMT_RED}$testlevel|FAILED${FMT_CLR}"
#       }
#     }

#     if {$test_failure_present} {
#       puts "\[${FMT_RED}FAILED${FMT_CLR}] [join $parsing_list " "]"
#     } else {
#       puts "\[${FMT_GRN}PASSED${FMT_CLR}] [join $parsing_list " "]"
#     }
#     unset parsing_list
#   }

#   if {$num_tests_failed != 0} {
#     set tst_word [expr {$num_tests_failed == 1 ? "TEST" : "TESTS"}]
#     puts "\[${FMT_RED}$num_tests_failed $tst_word FAILED${FMT_CLR}\]"
#   } else {
#     puts "\[${FMT_GRN}ALL TESTS PASSED${FMT_CLR}\]"
#   }
# }

# ###[ TESTS DATA ]################################
# array set LDATA [list {maze}       {2225 9}    \
#                       {natas}      {0000 34}   \
#                       {utumno}     {2227 8}    \
#                       {narnia}     {2226 9}    \
#                       {vortex}     {2228 27}   \
#                       {bandit}     {2220 34}   \
#                       {krypton}    {2231 7}    \
#                       {manpage}    {2224 7}    \
#                       {drifter}    {2230 15}   \
#                       {behemoth}   {2221 8}    \
#                       {leviathan}  {2223 7}    \
#                       {formulaone} {2232 6}]
  
# ###[ RUN TESTS ]#################################
# puts "~~~~~~~~~~~~~~~~~~~~~~"
# puts "\[\033\[0;35m\+\033\[0;0m] \033\[0;34mTEST LEVEL PARSING\033\[0;0m"
# puts "~~~~~~~~~~~~~~~~~~~~~~"
# test_level_parsing "LDATA"

# puts "\n~~~~~~~~~~~~~~~~~"
# puts "\[\033\[0;35m\+\033\[0;0m] \033\[0;34mALL VARIABLES\033\[0;0m"
# puts "~~~~~~~~~~~~~~~~~"
# foreach {var_name} [lsort [lrange [info vars] 0 end]] {
#   if [array exists $var_name] {
#     get_values_from_array "\033\[0;95m${var_name}\033\[0;0m" "$var_name"
#   } else {
#     if {[value_is_actually_a_list [set $var_name]]} {
#       get_values_from_list "\033\[0;94m${var_name}\033\[0;0m" [set $var_name]
#     } else {
#       puts "$var_name = [get_type_from_value [set $var_name]]"
#     }
#   }
# }

# puts "~~~~~~~~~~~~~~~~"
# puts "\[\033\[0;35m\+\033\[0;0m] \033\[0;34mALL COMMANDS\033\[0;0m"
# puts "~~~~~~~~~~~~~~~~"
# puts [join [lsort [info commands]] "\n"]

# set type_RE {value is a (.+) with a refcount}

# foreach v [info vars] {
#   if {[array exists $v]} {
#     puts "$v --> (array) [array names $v]"
#     continue
#   }

#   set type ""
#   if {! [regexp $type_RE [tcl::unsupported::representation [set $v]] -> type]} {
#     puts "$v --> (unknown) [set $v]"
#     continue
#   }
  
#   puts "$v --> ($type) [set $v]"
# }

proc get_vars {{ns ::}} {
  set all_vars ""
  set pat [set ns]::*
  set type_RE {value is a (.+) with a refcount}

  foreach var [info vars $pat] {
    set type ""
    if {[array exists $var]} {
      lappend all_vars $var "array"
    } else {
      set type_str [tcl::unsupported::representation [set $var]]
      if {! [regexp $type_RE $type_str -> type]} {
        lappend all_vars $var "unknown"
      } elseif {$type eq "pure string"} {
        if {[string length [set $var]] == 0} {
          lappend all_vars $var "empty string"
        } elseif {[string is integer [set $var]]} {
          lappend all_vars $var "integer"
        } elseif {[string is double [set $var]]} {
          lappend all_vars $var "double"
        } else {
          lappend all_vars $var "string"
        }
      } else {
        lappend all_vars $var $type
      }
    }
  }

  set CLRFMT "\033\[0;0m"
  puts [format {%-8s %-34s %s} "TYPES" "NAMES" "VALUES"]
  puts [format {%-8s %-34s %s} "*****" "*****" "******"]
  foreach {n t} [lsort -stride 2 -index 1 [lsort -stride 2 $all_vars]] {
    if {$t eq "empty string"} {
      puts [format {%-8s %-34s ""} "string" $n]
    } elseif {$t eq "string"} {
      puts [format {%-8s %-34s %s} $t $n [set $n]]
    } elseif {$t eq "integer"} {
      puts [format {%-8s %-34s %d} $t $n [set $n]]
    } elseif {$t eq "double"} {
      puts [format {%-8s %-34s %.2f} $t $n [set $n]]
    } elseif {$t eq "list" || $t eq "path"} {
      set lst [lrange [set $n] 0 end]
      set lst_len [llength $lst]
      if {$lst_len > 1} {
        set x 0
        foreach {item} [set lst] {
          if {[string length $item] > 38} {
            if {$x == 0} {
              puts [format {%-8s %-34s %-35s...} $t $n [string range $item 0 34]]
            } else {
              puts [format {%-8s %-34s %-35s...} "" "" [string range $item 0 34]]
            }
          } else {
            if {$x == 0} {
              puts [format {%-8s %-34s %-38s} $t $n $item]
            } else {
              puts [format {%-8s %-34s %-38s} "" "" $item]
            }
            incr x
          }
        }
      } else {
        puts [format {%-8s %-34s %s} $t $n $lst]
      }
    } elseif {$t eq "array"} {
      foreach {k} [array names $n] {
        set arrLabel "$n\($k\)"
        set arrValue [lindex [array get $n $k] 1]
        set val_strlen [string length $arrValue]

        if {$val_strlen > 38} {
          puts ${CLRFMT}[format {%-8s %-34s %s...} $t $arrLabel [string range $arrValue 0 34]]${CLRFMT}
        } else {
          puts ${CLRFMT}[format {%-8s %-34s %-38s} $t $arrLabel $arrValue]${CLRFMT}
        }
      }
    } else {
      puts [format {%-8s %-34s %-38} $t $n [set $n]]
    }
  }
}

get_vars